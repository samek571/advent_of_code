class Solution:
    def combinationSum(self, candidates, target: int):
        '''
        lists are gonna be generated by doing dfs in sorted repeating N-ary tree
        if it goes over the target --> fuck that path and try next one
        however if target is hit, add it to the result matrix
        '''

        result = [] #matrix
        candidates.sort() #so we can speed the process by cutting the rest of candidates if he go over the target
        lenn = len(candidates) #its O(1) however python calculates it each and everytime we do dfs vertex


        def dfs(target, index, path):
            if target <= 0:
                if target == 0:
                    result.append(path)
                return # basically just move one to the next one

            for i in range(index, lenn): #we utilize previous calculation
                dfs(target-candidates[i], i, path+[candidates[i]])
                #target, index, new path


        dfs(target, 0, [])
        return result

def main():
    sol = Solution()
    print(sol.combinationSum(candidates = [2,3,6,7], target = 7))
    print(sol.combinationSum(candidates = [2,3,5], target = 8))
    print(sol.combinationSum(candidates = [2], target = 1))

if __name__ == "__main__": main()