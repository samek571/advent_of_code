class Solution:
    def combinationSum2(self, candidates, target: int):
        result = []
        candidates.sort()  # so we can speed the process by cutting the rest of candidates if he go over the target
        lenn = len(candidates)  # its O(1) however python calculates it each and everytime we do dfs vertex

        def dfs(target, index, path):
            if target <= 0:
                if target == 0:
                    result.append(path)
                return  # basically just move one to the next one

            for i in range(index, lenn):  # we utilize previous calculation
                if i > index and candidates[i] == candidates[i-1]: continue

                #obv statement but basically everything else (unecesarry line)
                if candidates[i] <= target and (not path or path[-1] <= candidates[i]):
                    dfs(target - candidates[i], i + 1, path + [candidates[i]])

        dfs(target, 0, [])
        return result


def main():
    sol = Solution()
    print(sol.combinationSum2(candidates = [10,1,2,7,6,1,5], target = 8))
    print(sol.combinationSum2(candidates = [2,5,2,1,2], target = 5))


    print(sol.combinationSum2(candidates = [2,3,6,7], target = 7))
    print(sol.combinationSum2(candidates = [2,3,5], target = 8))
    print(sol.combinationSum2(candidates = [2], target = 1))

if __name__ == "__main__": main()

'''
lists are gonna be generated by doing dfs in sorted repeating N-ary tree
if it goes over the target --> fuck that path and try next one
however if target is hit, add it to the result matrix
'''

#apparently some bug with [1,1,1,1...]

# result = set()
# candidates.sort()  # so we can speed the process by cutting the rest of candidates if he go over the target
# lenn = len(candidates)  # its O(1) however python calculates it each and everytime we do dfs vertex
#
#
# def dfs(target, index, path):
#     if target <= 0:
#         if target == 0:
#             result.add(str(path))
#         return  # basically just move one to the next one
#
#     for i in range(index, lenn):  # we utilize previous calculation
#         dfs(target - candidates[i], i + 1, path + [candidates[i]])
#         # target, index, new path
#
#
# dfs(target, 0, [])
# return [eval(i) for i in result]